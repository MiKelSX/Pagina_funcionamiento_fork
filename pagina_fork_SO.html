import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, ChevronRight, Code, Move } from 'lucide-react';

const ForkVisualizer = () => {
  const [processes, setProcesses] = useState([]);
  const [terminalOutput, setTerminalOutput] = useState([]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [speed, setSpeed] = useState(1000);
  const [language, setLanguage] = useState('cpp');
  const [code, setCode] = useState('');
  const [error, setError] = useState('');
  const [draggingNode, setDraggingNode] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
  const [viewBox, setViewBox] = useState({ x: 0, y: 0, width: 1000, height: 700 });
  const svgRef = useRef(null);
  const containerRef = useRef(null);
  const textareaRef = useRef(null);

  const defaultCppCode = `#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int i, j, k;
    
    for (i = 0; i < 3; i++) {
        if (fork() == 0) {
            if (i == 1) {
                for (j = 0; j < 2; j++) {
                    if (fork() == 0) {
                        if (j == 1) {
                            for (k = 0; k < 2; k++) {
                                if (fork() != 0)
                                    break;
                            }
                        }
                        break;
                    }
                }
            }
            break;
        }
    }
    
    printf("PID: %d, PPID: %d\\n", getpid(), getppid());
    return 0;
}`;

  const defaultPythonCode = `import os
import sys

def main():
    for i in range(3):
        pid = os.fork()
        
        if pid == 0:
            if i == 1:
                for j in range(2):
                    pid_j = os.fork()
                    
                    if pid_j == 0:
                        if j == 1:
                            for k in range(2):
                                pid_k = os.fork()
                                
                                if pid_k != 0:
                                    break
                        break
            break
    
    print(f"PID: {os.getpid()}, PPID: {os.getppid()}")
    sys.exit(0)

if __name__ == "__main__":
    main()`;

  useEffect(() => {
    setCode(language === 'cpp' ? defaultCppCode : defaultPythonCode);
  }, [language]);

  const highlightCode = (code, lang) => {
    if (lang === 'cpp') {
      return code
        .replace(/\b(#include|int|for|if|break|return)\b/g, '<span class="text-purple-400">$1</span>')
        .replace(/\b(stdio\.h|stdlib\.h|unistd\.h|main|fork|printf|getpid|getppid)\b/g, '<span class="text-blue-400">$1</span>')
        .replace(/\b(\d+)\b/g, '<span class="text-green-400">$1</span>')
        .replace(/"([^"]*)"/g, '"<span class="text-yellow-300">$1</span>"')
        .replace(/(\/\/.*$)/gm, '<span class="text-gray-500">$1</span>');
    } else {
      return code
        .replace(/\b(import|def|for|if|break|return|in|range)\b/g, '<span class="text-purple-400">$1</span>')
        .replace(/\b(os|sys|fork|getpid|getppid|print|exit)\b/g, '<span class="text-blue-400">$1</span>')
        .replace(/\b(\d+)\b/g, '<span class="text-green-400">$1</span>')
        .replace(/"([^"]*)"/g, '"<span class="text-yellow-300">$1</span>"')
        .replace(/f"([^"]*)"/g, 'f"<span class="text-yellow-300">$1</span>"')
        .replace(/(#.*$)/gm, '<span class="text-gray-500">$1</span>');
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const textarea = e.target;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const newCode = code.substring(0, start) + '    ' + code.substring(end);
      setCode(newCode);
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + 4;
      }, 0);
    }
  };

  const parseAndExecute = () => {
    setError('');
    setProcesses([]);
    setTerminalOutput([]);
    setCurrentStep(0);
    setIsPlaying(false);

    try {
      let executionSteps = [];
      
      if (language === 'cpp') {
        executionSteps = parseCppCode(code);
      } else {
        executionSteps = parsePythonCode(code);
      }

      if (executionSteps.length === 0) {
        setError('No se detectaron llamadas fork() en el código');
        return;
      }

      simulateExecution(executionSteps);
      
    } catch (err) {
      setError(`Error al analizar el código: ${err.message}`);
    }
  };

  const parseCppCode = (cppCode) => {
    const steps = [];
    let pidCounter = 1;
    
    const iLoopMatch = cppCode.match(/for\s*\(\s*i\s*=\s*0\s*;\s*i\s*<\s*(\d+)/);
    const jLoopMatch = cppCode.match(/for\s*\(\s*j\s*=\s*0\s*;\s*j\s*<\s*(\d+)/);
    const kLoopMatch = cppCode.match(/for\s*\(\s*k\s*=\s*0\s*;\s*k\s*<\s*(\d+)/);
    
    if (!iLoopMatch) {
      throw new Error('No se encontró el bucle principal con variable i');
    }

    const iLimit = parseInt(iLoopMatch[1]);
    const jLimit = jLoopMatch ? parseInt(jLoopMatch[1]) : 0;
    const kLimit = kLoopMatch ? parseInt(kLoopMatch[1]) : 0;

    const baseSpacing = 200;
    const totalWidth = Math.max(iLimit * baseSpacing, 800);
    const centerX = 500;

    steps.push({
      pid: pidCounter++,
      ppid: 0,
      level: 0,
      i: 0,
      j: null,
      k: null,
      action: "Proceso inicial",
      isParent: true,
      x: centerX,
      y: 100
    });

    const iSpacing = totalWidth / (iLimit + 1);
    const iPositions = [];
    for (let i = 0; i < iLimit; i++) {
      iPositions.push(centerX - totalWidth / 2 + (i + 1) * iSpacing);
    }

    for (let i = 0; i < iLimit; i++) {
      const newPid = pidCounter++;
      steps.push({
        pid: newPid,
        ppid: 1,
        level: 1,
        i: i,
        j: null,
        k: null,
        action: `fork() en i=${i}`,
        isParent: false,
        x: iPositions[i],
        y: 250
      });

      if (i === 1 && jLimit > 0) {
        const parentPid = newPid;
        const parentX = iPositions[i];
        const jSpacing = 150;
        
        for (let j = 0; j < jLimit; j++) {
          const newPidJ = pidCounter++;
          const xOffset = (j - (jLimit - 1) / 2) * jSpacing;
          
          steps.push({
            pid: newPidJ,
            ppid: parentPid,
            level: 2,
            i: 1,
            j: j,
            k: null,
            action: `fork() en j=${j} desde PID ${parentPid}`,
            isParent: false,
            x: parentX + xOffset,
            y: 400
          });

          if (j === 1 && kLimit > 0) {
            let currentParent = newPidJ;
            let currentX = parentX + xOffset;
            
            for (let k = 0; k < kLimit; k++) {
              const newPidK = pidCounter++;
              steps.push({
                pid: newPidK,
                ppid: currentParent,
                level: 3 + k,
                i: 1,
                j: 1,
                k: k,
                action: `fork() en k=${k} desde PID ${currentParent}`,
                isParent: false,
                x: currentX,
                y: 550 + k * 150
              });
              currentParent = newPidK;
            }
          }
        }
      }
    }

    return steps;
  };

  const parsePythonCode = (pyCode) => {
    const steps = [];
    let pidCounter = 1;
    
    const iLoopMatch = pyCode.match(/for\s+i\s+in\s+range\((\d+)\)/);
    const jLoopMatch = pyCode.match(/for\s+j\s+in\s+range\((\d+)\)/);
    const kLoopMatch = pyCode.match(/for\s+k\s+in\s+range\((\d+)\)/);
    
    if (!iLoopMatch) {
      throw new Error('No se encontró el bucle principal con variable i');
    }

    const iLimit = parseInt(iLoopMatch[1]);
    const jLimit = jLoopMatch ? parseInt(jLoopMatch[1]) : 0;
    const kLimit = kLoopMatch ? parseInt(kLoopMatch[1]) : 0;

    const baseSpacing = 200;
    const totalWidth = Math.max(iLimit * baseSpacing, 800);
    const centerX = 500;

    steps.push({
      pid: pidCounter++,
      ppid: 0,
      level: 0,
      i: 0,
      j: null,
      k: null,
      action: "Proceso inicial",
      isParent: true,
      x: centerX,
      y: 100
    });

    const iSpacing = totalWidth / (iLimit + 1);
    const iPositions = [];
    for (let i = 0; i < iLimit; i++) {
      iPositions.push(centerX - totalWidth / 2 + (i + 1) * iSpacing);
    }

    for (let i = 0; i < iLimit; i++) {
      const newPid = pidCounter++;
      steps.push({
        pid: newPid,
        ppid: 1,
        level: 1,
        i: i,
        j: null,
        k: null,
        action: `fork() en i=${i}`,
        isParent: false,
        x: iPositions[i],
        y: 250
      });

      if (i === 1 && jLimit > 0) {
        const parentPid = newPid;
        const parentX = iPositions[i];
        const jSpacing = 150;
        
        for (let j = 0; j < jLimit; j++) {
          const newPidJ = pidCounter++;
          const xOffset = (j - (jLimit - 1) / 2) * jSpacing;
          
          steps.push({
            pid: newPidJ,
            ppid: parentPid,
            level: 2,
            i: 1,
            j: j,
            k: null,
            action: `fork() en j=${j} desde PID ${parentPid}`,
            isParent: false,
            x: parentX + xOffset,
            y: 400
          });

          if (j === 1 && kLimit > 0) {
            let currentParent = newPidJ;
            let currentX = parentX + xOffset;
            
            for (let k = 0; k < kLimit; k++) {
              const newPidK = pidCounter++;
              steps.push({
                pid: newPidK,
                ppid: currentParent,
                level: 3 + k,
                i: 1,
                j: 1,
                k: k,
                action: `fork() en k=${k} desde PID ${currentParent}`,
                isParent: false,
                x: currentX,
                y: 550 + k * 150
              });
              currentParent = newPidK;
            }
          }
        }
      }
    }

    return steps;
  };

  const simulateExecution = (steps) => {
    let step = 0;
    const interval = setInterval(() => {
      if (step < steps.length) {
        const currentStep = steps[step];
        setProcesses(prev => [...prev, currentStep]);
        
        const msg = `[Step ${step + 1}] PID ${currentStep.pid} (PPID: ${currentStep.ppid}) - ${currentStep.action}`;
        setTerminalOutput(prev => [...prev, msg]);
        
        step++;
      } else {
        clearInterval(interval);
        setTerminalOutput(prev => [...prev, `\n✓ Ejecución completada. Total: ${steps.length} procesos`]);
      }
    }, speed);
  };

  const handleMouseDown = (e, proc) => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    
    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) * (viewBox.width / rect.width) + viewBox.x;
    const mouseY = (e.clientY - rect.top) * (viewBox.height / rect.height) + viewBox.y;
    
    setDraggingNode(proc.pid);
    setDragOffset({
      x: mouseX - proc.x,
      y: mouseY - proc.y
    });
  };

  const handleContainerMouseDown = (e) => {
    if (e.button !== 0 || draggingNode !== null) return;
    setIsPanning(true);
    setPanOffset({ x: e.clientX, y: e.clientY });
  };

  const handleMouseMove = (e) => {
    if (draggingNode !== null) {
      const svg = svgRef.current;
      const rect = svg.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) * (viewBox.width / rect.width) + viewBox.x;
      const mouseY = (e.clientY - rect.top) * (viewBox.height / rect.height) + viewBox.y;
      
      setProcesses(prev => prev.map(proc => {
        if (proc.pid === draggingNode) {
          return {
            ...proc,
            x: mouseX - dragOffset.x,
            y: mouseY - dragOffset.y
          };
        }
        return proc;
      }));
    } else if (isPanning) {
      const dx = (panOffset.x - e.clientX) * (viewBox.width / containerRef.current.clientWidth);
      const dy = (panOffset.y - e.clientY) * (viewBox.height / containerRef.current.clientHeight);
      
      setViewBox(prev => ({
        ...prev,
        x: prev.x + dx,
        y: prev.y + dy
      }));
      
      setPanOffset({ x: e.clientX, y: e.clientY });
    }
  };

  const handleMouseUp = () => {
    setDraggingNode(null);
    setIsPanning(false);
  };

  useEffect(() => {
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [draggingNode, isPanning, dragOffset, panOffset, viewBox]);

  const handleReset = () => {
    setProcesses([]);
    setTerminalOutput([]);
    setCurrentStep(0);
    setIsPlaying(false);
    setError('');
    setViewBox({ x: 0, y: 0, width: 1000, height: 700 });
  };

  const renderTreeWithArrows = () => {
    const nodeWidth = 100;
    const nodeHeight = 60;

    return (
      <>
        {/* Flechas */}
        {processes.map(proc => {
          if (proc.ppid === 0) return null;
          const parent = processes.find(p => p.pid === proc.ppid);
          if (!parent) return null;

          const x1 = parent.x;
          const y1 = parent.y + nodeHeight / 2;
          const x2 = proc.x;
          const y2 = proc.y - nodeHeight / 2;

          return (
            <g key={`arrow-${proc.pid}`}>
              <defs>
                <marker
                  id={`arrowhead-${proc.pid}`}
                  markerWidth="10"
                  markerHeight="10"
                  refX="9"
                  refY="3"
                  orient="auto"
                >
                  <polygon points="0 0, 10 3, 0 6" fill="#60a5fa" />
                </marker>
              </defs>
              <line
                x1={x1}
                y1={y1}
                x2={x2}
                y2={y2}
                stroke="#60a5fa"
                strokeWidth="2"
                markerEnd={`url(#arrowhead-${proc.pid})`}
              />
              <text
                x={(x1 + x2) / 2 + 10}
                y={(y1 + y2) / 2}
                fill="#93c5fd"
                fontSize="11"
                fontWeight="bold"
              >
                fork()
              </text>
            </g>
          );
        })}

        {/* Nodos */}
        {processes.map(proc => (
          <g 
            key={proc.pid} 
            className="animate-fadeIn"
            onMouseDown={(e) => handleMouseDown(e, proc)}
            style={{ cursor: 'grab' }}
          >
            <rect
              x={proc.x - nodeWidth / 2}
              y={proc.y - nodeHeight / 2}
              width={nodeWidth}
              height={nodeHeight}
              rx="8"
              fill={proc.isParent ? '#e9d5ff' : '#dbeafe'}
              stroke={proc.isParent ? '#a855f7' : '#3b82f6'}
              strokeWidth="3"
              className={draggingNode === proc.pid ? 'opacity-80' : ''}
            />
            <text
              x={proc.x}
              y={proc.y - 8}
              textAnchor="middle"
              fontSize="14"
              fontWeight="bold"
              fill="#1f2937"
              pointerEvents="none"
            >
              PID: {proc.pid}
            </text>
            <text
              x={proc.x}
              y={proc.y + 8}
              textAnchor="middle"
              fontSize="11"
              fill="#4b5563"
              pointerEvents="none"
            >
              PPID: {proc.ppid}
            </text>
            <text
              x={proc.x}
              y={proc.y + 22}
              textAnchor="middle"
              fontSize="10"
              fill="#6b7280"
              pointerEvents="none"
            >
              {proc.i !== null && `i=${proc.i}`}
              {proc.j !== null && ` j=${proc.j}`}
              {proc.k !== null && ` k=${proc.k}`}
            </text>
          </g>
        ))}
      </>
    );
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-800 text-white p-6">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-4xl font-bold mb-2 text-center bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
          Visualizador Interactivo de fork()
        </h1>
        <p className="text-center text-gray-400 mb-6">Escribe tu código y visualiza la ejecución de procesos</p>

        {/* Editor */}
        <div className="bg-gray-800 rounded-lg p-6 mb-6 shadow-xl border border-gray-700">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-bold flex items-center gap-2">
              <Code size={24} className="text-blue-400" />
              Editor de Código
            </h2>
            <div className="flex gap-2">
              <button
                onClick={() => setLanguage('cpp')}
                className={`px-4 py-2 rounded-lg transition ${
                  language === 'cpp' 
                    ? 'bg-orange-600 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                C++
              </button>
              <button
                onClick={() => setLanguage('python')}
                className={`px-4 py-2 rounded-lg transition ${
                  language === 'python' 
                    ? 'bg-yellow-600 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                Python
              </button>
            </div>
          </div>

          <div className="relative">
            <textarea
              ref={textareaRef}
              value={code}
              onChange={(e) => setCode(e.target.value)}
              onKeyDown={handleKeyDown}
              className="w-full h-64 bg-gray-900 text-gray-300 font-mono text-sm p-4 rounded border border-gray-700 focus:border-blue-500 focus:outline-none resize-none"
              spellCheck="false"
              style={{ 
                caretColor: 'white',
                tabSize: 4
              }}
            />
          </div>

          {error && (
            <div className="mt-4 bg-red-900 border border-red-600 text-red-200 p-3 rounded">
              ⚠️ {error}
            </div>
          )}

          <button
            onClick={parseAndExecute}
            className="mt-4 w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 px-6 py-3 rounded-lg font-bold text-lg transition"
          >
            🚀 Analizar y Ejecutar
          </button>
        </div>

        {processes.length > 0 && (
          <>
            {/* Controles */}
            <div className="bg-gray-800 rounded-lg p-4 mb-6 shadow-xl border border-gray-700">
              <div className="flex items-center justify-between flex-wrap gap-4">
                <div className="flex gap-2 items-center">
                  <button
                    onClick={handleReset}
                    className="flex items-center gap-2 bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg transition"
                  >
                    <RotateCcw size={20} />
                    Reiniciar
                  </button>
                  <div className="flex items-center gap-2 text-sm text-gray-300 bg-gray-700 px-3 py-2 rounded">
                    <Move size={16} />
                    Arrastra nodos o el fondo para navegar
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <label className="text-sm">Velocidad:</label>
                  <select
                    value={speed}
                    onChange={(e) => setSpeed(Number(e.target.value))}
                    className="bg-gray-700 px-3 py-2 rounded border border-gray-600"
                  >
                    <option value={2000}>Lenta (2s)</option>
                    <option value={1000}>Normal (1s)</option>
                    <option value={500}>Rápida (0.5s)</option>
                  </select>
                </div>
              </div>
            </div>

            {/* Árbol */}
            <div className="bg-gray-800 rounded-lg p-6 mb-6 shadow-xl border border-gray-700">
              <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
                <span className="text-blue-400">📊</span> Árbol de Procesos (Arrastra para navegar)
              </h2>
              <div 
                ref={containerRef}
                className="overflow-hidden bg-gray-900 rounded border-2 border-gray-700"
                style={{ height: '600px', cursor: isPanning ? 'grabbing' : 'grab' }}
                onMouseDown={handleContainerMouseDown}
              >
                <svg 
                  ref={svgRef}
                  width="100%" 
                  height="100%"
                  viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}
                  preserveAspectRatio="xMidYMid meet"
                >
                  {renderTreeWithArrows()}
                </svg>
              </div>
            </div>

            {/* Terminal */}
            <div className="bg-gray-800 rounded-lg p-6 shadow-xl border border-gray-700">
              <h2 className="text-2xl font-bold mb-4 flex items-center gap-2">
                <span className="text-green-400">💻</span> Salida del Terminal
              </h2>
              <div className="bg-black rounded p-4 font-mono text-sm overflow-auto" style={{ maxHeight: '300px' }}>
                {terminalOutput.map((line, idx) => (
                  <div key={idx} className="text-green-400 mb-1">
                    {line}
                  </div>
                ))}
              </div>
            </div>
          </>
        )}
      </div>

      <style>{`
        @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
        }
        .animate-fadeIn {
          animation: fadeIn 0.5s ease-out;
        }
      `}</style>
    </div>
  );
};

export default ForkVisualizer;